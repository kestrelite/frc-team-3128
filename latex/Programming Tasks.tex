\documentclass[a4paper]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[margin=1in]{geometry}
\usepackage[T1]{fontenc}
\title{FRC Programming Tasks List}
\author{Noah Sutton-Smolin}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

\begin{document}
\setcounter{tocdepth}{2}\maketitle\tableofcontents\pagebreak

This is a compilation of the introductory tasks for FRC programming. Each of these tasks are to be completed in order.

\subsection{Task 00 - Initial lesson}

Don't be lazy.

Do things right the first time.

This is the imperative of the programmer.

Don't be lazy.
\section{Basic Usage}
\subsection{Task 01 - \lstinline{DebugLog} usage}
\subsubsection{Goal} Learn the use of \lstinline{DebugLog} to write outputs to the console
\subsubsection{Details} One should never use \lstinline{System.out.print*} to print console outputs. The reasons are varied, but primarily, the outputs become cluttered, unreadable, and generally unusable. 

The benefit to \lstinline{DebugLog} is that it enforces three things:
\begin{enumerate}\item{Log message severity, which can be filtered (which is useful for obvious reasons)}\item{Log message timestamps, which do not normally come with system outs}\item{Log message sources, which show where a message actually came from. This is critically important when diagnosing software issues.}\end{enumerate}

The \lstinline{RobotTemplate} class is actually what's run by the FRC software, and it interfaces with the \lstinline{Global} class. You should never modify the \lstinline{RobotTemplate} class.

Bear in mind, there is a critical difference between the \lstinline{DEBUG} and \lstinline{STREAM} levels: Debug is to be used for individual debugging messages. Stream is to be used for messages which would otherwise flood the console, but are useful for low-level debugs (like controller positions, or event triggering, etc.)
\subsubsection{Task} Write one output of each severity level to the console when teleop starts, in order, using the \lstinline{DebugLog} class.
\subsubsection{Success} \begin{enumerate}\item{Each output is written to the console successfully.}\item{No file has been modified except for the \lstinline{Global} class.}\item{Only the \lstinline{initializeTeleop()} function in the \lstinline{Global} class has been modified.}\item{No \lstinline{System.out.*} files are used.}\end{enumerate}

\subsection{Task 02 - Utilizing the \lstinline{Global} class}
\subsubsection{Goal} Understand the function of the \lstinline{Global} class with respect to shared resources and robot intialization.
\subsubsection{Details} The \lstinline{Global} class is used to hold all global resources and create initalization functions. These functions are wrapped to from RobotTemplate, which you are free to inspect.

The \lstinline{static} modifier must be used before all \lstinline{Global} variables; if you do not know what the static modifier does, you are free to do research into it. However, in short, the static modifier makes it so that only one instance of a variable can exist in a class. This means any class resource can be accessed using \lstinline{[CLASSNAME].[RESOURCENAME]} instead of \lstinline{[INSTANCENAME].[RESOURCENAME]}.

With respect to our given setup, if we had a jaguar (motor) in \lstinline{Global} declared as: \lstinline{public static final Jaguar jag1 = new Jaguar(1,2);} it can be accessed from anywhere in the code by using \lstinline{Global.jag1}; however, if we declared it like so: \lstinline{public final Jaguar jag1 = new Jaguar(1,2);} without the \lstinline{static} modifier, then it could \textit{not} be accessed using \lstinline{Global.jag1}, which makes it an ineffective declaration for our purposes.

The Watchdog is not something you should ever personally need to deal with, as it is handled by the system, but it is important to understand. The Watchdog makes sure that the robot's code hasn't stopped or frozen. The act of "feeding" the watchdog ensures that the FRC system does not automatically kill our robot. The watchdog is called using:

\lstinline{Watchdog.getInstance().feed();}

This gets the current instance of the Watchdog from the \lstinline{Watchdog} class (through the static getInstance() function), and feeds it.
\subsubsection{Task} Create a \lstinline{Jaguar} in the global class. Change its power in each of the \lstinline{initialize} functions. Be sure to call \lstinline{Watchdog} somewhere once.
\subsubsection{Success} \begin{enumerate}\item{The power was successfully set in each initialization function.}\item{The \lstinline{Watchdog} was fed once.}\item{No file was modified except for \lstinline{Global}.}\end{enumerate}

\subsection{Task 03 - Understanding function timings}
\subsubsection{Goal} Understand when the initialization functions are called in game.
\subsubsection{Details} The \lstinline{RobotTemplate} class controls the timings in the \lstinline{Global} class. You need to understand when and under which circumstances the functions in the Global class would be invoked. \begin{itemize}\item{\lstinline{initializeRobot()} is invoked once when the robot's code starts up.}\item{\lstinline{initializeDisabled()} is invoked once when the robot enters the disabled state before and after the game.}\item{\lstinline{initializeAutonomous()} is invoked once when the robot's autonomous phase is about to begin.}\item{\lstinline{initializeTeleop()} is invoked once when the robot's teleoperated phase is about to begin.}\end{itemize}

Every robot task in-game will be handled by the \lstinline{EventManager}. The initialization functions are only used to set up \lstinline{EventManager}'s sequencing so that everything else follows suit and makes sense. \begin{itemize}\item{\lstinline{robotKill()} is a predefined function which you can invoke when you wish to shut off the robot entirely.}\item{\lstinline{robotStop()} is a function you can define which turns off the robot without disconnecting or disabling it.}\end{itemize}
\subsubsection{Task} None
\subsubsection{Success} You read this section, didn't you? Go read it again.


\section{Sensor and Motor Usage}\setcounter{subsection}{3}

\subsection{Task 04 - Using raw motors with \lstinline{MotorLink}}
\subsubsection{Goal} Learn how to use the \lstinline{MotorLink} class to more efficiently interface with the \lstinline{Jaguar}s
\subsubsection{Details} The \lstinline{MotorLink} class was written with a primary purpose of simplifying the logic beind encoders (which measure the angle of wheels) and speed controllers (which control the rate that motors move). As such, \textit{all motors should be written using} \lstinline{MotorLink}. 

It is important to understand how to declare a \lstinline{Jaguar}, though, for this task.

The motor you will be creating will take one argument: a \lstinline{Jaguar}. You can declare the \lstinline{Jaguar} in-line. Explore the \lstinline{MotorLink} class and its functions. Bear in mind that it has been stripped down from its full form, as \lstinline{Events} have not been introduced yet, and the \lstinline{MotorSpeedControl} requires events.
\subsubsection{Task} Declare a \lstinline{MotorLink} as a static resource in \lstinline{Global}. Set its powers scalar to a valid value. Set the motor power.
\subsubsection{Success} \begin{enumerate}\item{The \lstinline{MotorLink} is declared as a static resource.}\item{The \lstinline{Jaguar} is \textit{not} declared as a static resource, and is instead consumed by \lstinline{MotorLink}.}\item{The power scalar and powers are set properly.}\item{The code is error-free.}\end{enumerate}

\subsection{Task 05 - Using and declaring sensors}
\subsubsection{Goal} Declare sensors and use their values.
subsubsection{Details} Sensors are primarily accessible through the \lstinline{frc3128.HardwareLink} package. For instance, a gyroscope will use the \lstinline{GyroLink} class (locaed in \lstinline{frc3128.HardwareLink.GyroLink}) for communications. 

\lstinline{GyroLink} consumes a \lstinline{Gyroscope} in its constructor.
\subsubsection{Task} Declare a new \lstinline{GyroLink} as a static \lstinline{Global} resource. Print its value on teleop init.
\subsubsection{Success}\begin{itemize}\item{The \lstinline{GyroLink} is declared properly.}\item{The \lstinline{Gyroscope} is consumed by the \lstinline{GyroLink} constructor.}\item{The value of the gyro is printed out when the robot initializes.}\end{itemize}

\subsection{Task 06 - Using raw encoders and angles}
\subsubsection{Goal} Create an encoder and read out its angle.
\subsubsection{Details} None.
\subsubsection{Task} Encoders are devices which keep track of the angle of a given motor. The \lstinline{MotorLink} class can be linked with an \lstinline{AbstractEncoder}.

Create a \lstinline{MagneticPotEncoder} and print out its raw angle on teleop init.
\subsubsection{Success} \begin{itemize}\item{Only the \lstinline{MagneticPotEncoder} is kept as a static resource.}\item{The raw angle is printed out using \lstinline{DebugLog} at the appropriate level.}\end{itemize}

\subsection{Task 07 - Using motors in conjunction with encoders}
\subsubsection{Goal} Properly use raw encoders and their angles.
\subsubsection{Details} \lstinline{AbstractEncoder} is an abstract class which has two required functions: \lstinline{getAngle()} and \lstinline{getRawValue()}. There are two predefined implementations: \lstinline{GyroEncoder} and \lstinline{MagneticPotEncoder}. 

There is a static function in \lstinline{frc3128.Util.RobotMath} called \lstinline{normalizeAngle()}; this function must be invoked on all angle values continuously, as it keeps the angle values to within normal range. We keep track of angles from 0 to 360 degrees. 
\subsubsection{Task} Create a new \lstinline{MotorLink} using a \lstinline{MagneticPotEncoder}. Read out the angle, and print the normalized value to the print stream.
\subsubsection{Success}\begin{itemize}\item{Create a \lstinline{MotorLink} and associated \lstinline{AbstractEncoder} and \lstinline{Jaguar}.}\item{The \lstinline{AbstractEncoder} and \lstinline{Jaguar} are fully consumed by the \lstinline{MotorLink}.}\item{The angle from the \lstinline{MotorLink} is normalized and printed out.}\item{The print out uses \lstinline{DebugLog}.}\end{itemize}

\subsection{Task 08 - Using the \lstinline{PneumaticsManager}}
\subsubsection{Goal} Learn the uses of \lstinline{PneumaticsManager}.
\subsubsection{Details} \lstinline{PneumaticsManager} is a class designed to control the pneumatic air compression systems on the robot. The pneumatics system uses compressors and two-sided solenoids called Festos to control air flow.

The \lstinline{PneumaticsManager} must be declared with a compressor. When a new piston is created, it returns a \lstinline{PistonID}, which is a reference value used by the \lstinline{PneumaticsManager} to handle piston movements.
\subsubsection{Task} Initialize the \lstinline{PneumaticsManager}. Turn the compressor off, then on. Create a piston, and record the \lstinline{PistonID} as a static global resource. Turn the piston forward, then flip its state, then reverse its polarity.
\subsubsection{Success} All tasks completed without error.


\section{Event Manager}\setcounter{subsection}{8}

\subsection{Task 09 - Single run events}
\subsubsection{Goal} Learn how and when certain events are executed, and how to trigger single-run events.
\subsubsection{Details} The \lstinline{EventManager} is a rather simple block of code which drives the entire robot. It takes \lstinline{Events}, or small blocks of code, and runs them in the sequence they were queued.

An \lstinline{Event} is an abstract class. If you don't know what abstract classes are, it is strongly suggested that you look up the documentation for them. An Event must be declared as a class. That means, to create an event, you must do the following:

\begin{verbatim}
	class EventImpl extends Event {
		public void execute() {
			//your code
		}
	}
\end{verbatim}

If you do not have the \lstinline{execute()} function, you will not be adhering to the \lstinline{Event} abstract class, and NetBeans will barf errors in your face.

You can also declare an \lstinline{Event} inline, but it \textit{must} have an implementation.

\begin{verbatim}
	Event e = new Event() {
		public void execute() {
			//your code
		}
	};
\end{verbatim}

You can also declare an \lstinline{Event} inline, and directly queue it:

\begin{verbatim}
	(new Event() {
		public void execute() {
			//your code
		}
	}).registerIterableEvent();
\end{verbatim}

The \lstinline{Event} has several critical functions:
\begin{itemize}\item{\lstinline{registerSingleEvent()} will insert the \lstinline{Event} into the \lstinline{EventManager}'s queue, and run it once before removing it.}\item{\lstinline{registerIterableEvent()} will insert the \lstinline{Event} into the \lstinline{EventManager}'s queue, and it won't be removed until it is cancelled directly (or the entire \lstinline{Event} stack is dropped).}\item{\lstinline{registerTimedEvent(int msec)} will create a new instance of a \lstinline{TimerEvent} and register it as an iterable event. When the timer expires, the selected \lstinline{Event} will be run. If you're going to call this function, it is \textit{highly} recommended that you call \lstinline{prepareTimer()} first.}\end{itemize}

That's it for starting events. For cancelling events: \begin{itemize}\item{\lstinline{cancelEvent()} will cancel the running event.}\item{\lstinline{cancelTimedEvent()} will cancel the event's execution timer.}\item{\lstinline{cancelEventAfter(int msec)} will cancel the event after a given amount of time.}\end{itemize}

The \lstinline{EventManager} is called automatically in \lstinline{RobotTemplate}. Do not modfiy \lstinline{RobotTemplate}. Do not manually invoke the \lstinline{EventManager} de-queueing function.
\subsubsection{Task} Create a single run event which will print out some text.
\subsubsection{Success} \begin{enumerate}\item{The text is printed out using \lstinline{DebugLog} and an \lstinline{Event}.}\item{No resources are kept longer than they are needed.}\end{enumerate}

\subsection{Task 10 - Single run events and their execution order}
\subsubsection{Goal} Understand the queue nature of the \lstinline{EventManager}.
\subsubsection{Details} The \lstinline{EventManager} uses a FIFO (First In, First Out) queue. \lstinline{Events} will be run in the order they are inserted in the queue.
\subsubsection{Task} Create a program which will print out "Hello," then "World," then set a motor on (1,2) to 50\% power.
\subsubsection{Success} \begin{enumerate}\item{No extraneous resources are kept.}\item{\lstinline{DebugLog} is used for printing.}\item{The motor is created using \lstinline{MotorLink} and is created as a global static resource.}\item{The program will execute successfully.}\end{enumerate}

\subsection{Task 11 - Iterable Events}
\subsubsection{Goal} Understand and use iterable events.
\subsubsection{Details} Iterable events are the same as single run events, but they are not deleted on the \lstinline{EventManager}'s cleanup step. This means they will run continuously unless cancelled expliitly.
\subsubsection{Task} Create a program which will print out "Hello" continuously. After 1.5 seconds, a separate event should print out "World". 
\subsubsection{Success} \begin{enumerate}\item{No resources are kept which are not needed.}\item{It operates as described above.}\end{enumerate}

\subsection{Task 12 - Iterable events and cancellation}
\subsubsection{Goal} Understand and use iterable events.
\subsubsection{Details} Iterable events must be cancelled manually, otherwise they will not be cancelled.
\subsubsection{Task} Create a program which will print out "Hello" continuously. After 1.5 seconds, a separate event should print out "World", at which point, the "Hello" event should stop printing. 
\subsubsection{Success} \begin{enumerate}\item{No resources are kept which are not needed.}\item{It operates as described above.}\item{After two seconds, the robot should still be able to support additional code.}\end{enumerate}

\subsection{Task 13 - Events and call stack order}
\subsubsection{Goal} Experiment with events and callback orders.
\subsubsection{Details} None.
\subsubsection{Task} Create a program which will start by setting a motor on (1,2) to 50\% power, then print out "Hello" continuously. Another event should stop the "Hello" event, then print out "World" and set the motor to 0\% power.
\subsubsection{Success} \begin{enumerate}\item{Task as described.}\item{No extraneous resources are kept.}\end{enumerate}

\subsection{Task 14 - More using events to control robots (Optional)}
\subsubsection{Goal} Understand how events are used to control the robot.
\subsubsection{Details} None.
\subsubsection{Task} Create a \lstinline{MotorLink} global static resource with a motor on \lstinline{(1,2)}. After 500msec, set its power to 50\%. After 1000msec, set its power to -50\%. After 1500 msec, set its power to 0\%. 
\subsubsection{Success} Completion of the above.

\subsection{Task 15 - More using events to control robots (Optional)}
\subsubsection{Goal} Understand how events are used to control the robot.
\subsubsection{Details} None.
\subsubsection{Task} Create a piston (use irrelevant port numbers) and change its state twice over the course of two seconds.
\subsubsection{Success} Completion of the above.

\subsection{Task 16 - Self-reregistering events}
\subsubsection{Goal} Understand how single events can be sequenced with themselves to run an event a given number of times.
\subsubsection{Details} None.
\subsubsection{Task} Write an event which will execute four times, printing each time.
\subsubsection{Success} Completion of the above.

\subsection{Task 17 - [Empty]} Skip this section for the time being.


\section{Listener Manager}\setcounter{subsection}{17}

\subsection{Task 18 - Registering events with \lstinline{ListenerManager}}
\subsubsection{Goal} Understand how \lstinline{ListenerManager} and how listener callbacks work.
\subsubsection{Details} \lstinline{ListenerManager} associates strings and integers with events. When an event is registered with the \lstinline{ListenerManager}, it must be given an associated string or integer, known as the "key." 

When the key is invoked, the \lstinline{ListenerManager} will go through the list and find all events with matching keys, then execute them in order. For example, let's say I have an event:

\begin{verbatim}
	Event e = new Event() {
		public void execute() {
			Global.motFL.setSpeed(0.5);
		}
	}
\end{verbatim}

The event obviously will set the power of \lstinline{motFL} to 50\%. Now, what if I want to do this when I press the X button? (For the purposes of this example, we're assuming the controller's event is already running)

\lstinline{ListenerManager.addListener(e, ''buttonXDown");} or:\newline\indent\lstinline{ListenerManager.addListener(e, ListenerConst.BTN\_X\_DOWN); //better for clarity}

The \lstinline{ListenerCosnt} class contains most of the available Listener constants. This is critically important for the Listeners, as this greatly increases the clarity and consistency of what you're doing. For instance (and this has happened), one can make a typo in \lstinline{buttonXDown}, but one cannot easily make a typo in \lstinline{ListenerConst.BTN\_X\_DOWN}.

To call a Listener, one simply needs to call \lstinline{ListenerManager.callListener()}; both a \lstinline{String} and an \lstinline{int} are acceptable arguments.
\subsubsection{Task} Create an event, and register it to trigger when the string "test" is called.
\subsubsection{Success} Self-explanatory.

\subsection{Task 19 - Running \lstinline{ListenerManager} callbacks}
\subsubsection{Goal} Call back events appropriately
\subsubsection{Details} None.
\subsubsection{Task} Create an event for \lstinline{"Hello "}, and event for \lstinline{"World"}, and register both of them under \lstinline{ListenerManager} for the key \lstinline{"helloworld"}. Call the \lstinline{"helloworld"} key after 1.5 seconds.
\subsubsection{Success} Program prints out ``Hello World''

\subsection{Task 20 - Setting up and running controllers}
\subsubsection{Goal} Understand how controllers interface with the program.
\subsubsection{Details} Controllers are all contained in \lstinline{frc3128.HardwareLink.Controller}. They are always \lstinline{Events}, and register themselves iterably when the constructors are run. 

As an example, we'll look at \lstinline{XControl}, which interfaces with an XBox 360 controller. Every iteration, \lstinline{XControl} checks to see if the controller's state has changed, and if so, what has. This is critically important for two reasons: first, it saves time. The program will only run what needs to be run when it needs to be run. Second, it's cleaner; the controller runs in the background, and buttons can be easily interlaced with the running program.

Controllers require a port number; this goes back to the driver station. 

Controllers should always be global resources.
\subsubsection{Task} Create an XBox controller (\lstinline{XControl}) on port 1. Make it such that, when button X is pressed, the program will print out "hello" for 1.5 seconds, then stop. Make it such that, when button Y is pressed, the program will print out "world" for 1.5 seconds, then stop.
\subsubsection{Success} Success at the above.

\subsection{Task 21 - Creating an event for driving}
\subsubsection{Goal} Create an event for driving.
\subsubsection{Details} Drive events are not iterable events; instead, they are registered with \lstinline{ListenerManager} and are called when controller updates occur. 
\subsubsection{Task} Create a Drive event which runs on \lstinline{UPDATE\_DRIVE} and will set the power of a \lstinline{motLeft} motor to the value of the Y axis on joystick 1. The drive event should also set the power of a \lstinline{motRight} motor to the value of the Y axis on joystick 2.
\subsubsection{Success} Success at the above.


\section{Event Sequencing}

\subsection{Task 23 - Creating and using the \lstinline{EventSequencer}}
\subsubsection{Goal} Understand how \lstinline{EventSequencers} are used, how they make your life easier, and how they're used for autonomous.
\subsubsection{Details} \lstinline{EventSequencer} is a class which runs events in a given sequence. This is incredibly useful for things like turning a piston on, then off after half a second.

The \lstinline{EventSequencer} is most useful during autonomous, however. Since \lstinline{SequenceEvents} define their own exit conditions, they are indefinitely versatile for use in autonomous; simply define an event, define when you consider the event complete, then move on to the next one. The entire autonomous program can be written this way. 

The tools for sequencing events are in the \lstinline{frc3128.EventManager.EventSequencer} package. A \lstinline{SequenceEvent} is still an \lstinline{Event}. A \lstinline{SingleSequence} is still a \lstinline{SequenceEvent}.

The \lstinline{EventSequencer} is an iterable event which is run by the \lstinline{EventManager}. \lstinline{SequenceEvents} are always written to be single events, but have another abstract function: \lstinline{exitConditionMet()}. When \lstinline{exitConditionMet()} returns \lstinline{true}, the event is stopped, and the \lstinline{EventSequencer} moves on to the next event in the queue.

Each \lstinline{SequenceEvent} has several internal functions, one of which is \lstinline{getRunTimeMillis()}. This function is used to determine how long the event has been running, and is useful for \lstinline{exitConditionMet} functions which depend on a certain amount of time.

A \lstinline{SingleSequence} event is a special case of the \lstinline{SequenceEvent} and is, for all intents and purposes, syntactic sugar. It provides an easy way to create an event which will run once and only once. Even though the \lstinline{EventSequencer} requires a \lstinline{SequenceEvent}, remember that a \lstinline{SingleSequence} is \textit{also} a \lstinline{SequenceEvent}; that's the way inheritance works.

A \lstinline{SingleSequence}'s \lstinline{exitConditionMet()} function reads:

\begin{verbatim}
	/**
	 * Exits immediately; will always return true.
	 * 
	 * @return true
	 */
	public final boolean exitConditionMet() {return true;}
\end{verbatim}

The \lstinline{EventSequencer} works off FIFO, so whatever you register with it first will run first.

The \lstinline{EventSequencer} will start when \lstinline{EventSequencer}'s \lstinline{startSequence()} method is invoked. To run it more than once, one must \lstinline{resetSequence()}. One can always \lstinline{stopSequence()}. An \lstinline{EventSequencer} is also an \lstinline{Event}.
\subsubsection{Task} Create an \lstinline{EventSequencer} and add a Hello \lstinline{SingleSequence} to it, as well as a World \lstinline{SingleSequence}. Trigger the \lstinline{EventSequencer}.
\subsubsection{Success} Success at the above.

\subsection{Task 23}
\subsubsection{Goal} Use alternate exit conditions.
\subsubsection{Details} None.
\subsubsection{Task} Create a \lstinline{SequenceEvent} and have it print out until it exits in 1.5 seconds. Trigger two other events after this.

\section*{You win!}
\end{document}

%\subsection{Task 00}
%\subsubsection{Goal}
%\subsubsection{Details}
%\subsubsection{Task}
%\subsubsection{Success}